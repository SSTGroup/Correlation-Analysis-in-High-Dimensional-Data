%   File: MCCA_CompleteModelSelection.m
%   Copyright (c) <2018> <University of Paderborn>
%   Permission is hereby granted, free of charge, to any person
%   obtaining a copy of this software and associated documentation
%   files (the "Software"), to deal in the Software without restriction,
%   including without limitation the rights to use, copy, modify and
%   merge the Software, subject to the following conditions:
%
%   1.) The Software is used for non-commercial research and
%       education purposes.
%
%   2.) The above copyright notice and this permission notice shall be
%       included in all copies or substantial portions of the Software.
%
%   3.) Publication, Distribution, Sublicensing, and/or Selling of
%       copies or parts of the Software requires special agreements
%       with the University of Paderborn and is in general not permitted.
%
%   4.) Modifications or contributions to the software must be
%       published under this license. The University of Paderborn
%       is granted the non-exclusive right to publish modifications
%       or contributions in future versions of the Software free of charge.
% 
%   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
%   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
%   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
%   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
%   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
%   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
%   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
%   OTHER DEALINGS IN THE SOFTWARE.
%
%   Persons using the Software are encouraged to notify the
%   Signal and System Theory Group at the University of Paderborn
%   about bugs. Please reference the Software in your publications
%   if it was used for them.
% ------------------------------------------------------------------------
% SYNTAX:   
%
% [CorrEst,x_corrs] = MCCA_CompleteModelSelection(X,ITC,Pfa,varargin)
%
% OVERVIEW: 
%
% This function takes a collection of matrices, X_p in R^(n_p x M) for 
% p = 1,2,...,P, each containing M samples of an n_p-dimensional noisy
% signal space, assumed to be generated by a P-channel model. The function
% computes an estimate of the correlation structure between all channels.  
% The method for estimating correlation structure proceeds as follows,
%
%   1)  Jointly estimate canonical variates {z_1^(i),z_2^(i),...,z_P^(i)} 
%       for stages i = 1,2,...,max{n_p} using the MCCA method with the
%       MAXVAR criterion and the constraint that z_1^(i) is uncorrelated
%       with z_1^(j) for i not equal to j.
%   2)  Estimate the pairwise model order for each combination of channels.
%       This is done by computing ML estimates of the canonical 
%       correlations between X_p and X_q, and applying the sequence of 
%       hypothesis tests based on the Barlett-Lawley statistic to find 
%       the number of pairwise correlations, d_pq.
%   3)  Identify which jointly estimated canonical variates have the 
%       largest magnitude, same-stage inner products for each pair of 
%       channels. If |<z_p^(i),z_q^(i)>| is one of the d_pq largest inner
%       products for channel p and channel q, a nonzero correlation is 
%       identified between the ith signals of X_p and X_q. Note that 
%       these will not necessarily be signals from stages 1,2,...,d_pq.
%       
% INPUTS:
%
% 'X'               Cell array of size n_sets x 1.
%                   The pth cell contains a matrix of size n_p x M.  It is 
%                   the matrix of observations of the pth data channel.
%
% 'ITC'             String.
%                   Options are 'ht', 'mdl', or 'aic'. Describes whether
%                   the detector used for the determining the number of
%                   pairwise correlations should use a traditional binary
%                   hypothesis test, the minimum descriptor length, or the
%                   akaike information criterion
%
% 'varargin'        Optional inputs.
%
% 'varargin{1}'     Cell array of the same size as 'X'.
%                   If used, contains orthonormal bases for the data sets.
%                   
% OUTPUTS:  
%
% 'CorrEst'         Matrix of size 'n_sets choose two' x max{n_p}.
%                   Table of estimated correlations for the collection of
%                   data sets. Each row corresponds to a pair of data sets.  
%                   Each column corresponds to a signal. A one in the ith
%                   column of the jth row indicates that a nonzero
%                   correlation exists between the ith signals of the data
%                   sets indicated by the jth row of 'x_corrs'.
%
% 'x_corrs'         Matrix of size 'n_sets choose two' x 2.
%                   Contains the indices of the data sets for all pairwise
%                   comparisons. Tells you which data sets correspond to
%                   which rows of CorrEst.
%                   
%
% DEPENDENCIES:
%
% N/A
%       
% REFERENCES:
%
% This method:
% [1]   T. Marrinan, T. Hasija, C. Lameiro, and P. Schreier. "Complete 
%       model selection in multiset canonical correlation analysis." 
%       (In preparation.)
%
% The maxmin method:
% [2]   Song, Yang, Peter J. Schreier, David Ramírez, and Tanuj Hasija. 
%       "Canonical correlation analysis of high-dimensional data with very 
%       small sample support." Signal Processing 128 (2016): 449-458.
%
% ------------------------------------------------------------------------
% CREATED:      20/02/2018 by Tim Marrinan
%
% LAST EDITED:  20/02/2018 by Tim Marrinan
%               21/02/2018 by Tim Marrinan
%
% NOTES: 
%
% Currently only coded for real data. [TM 21/02/2018]
%
% Right now I only compute canonical variates for each data set up to the 
% dimension of the smallest set. This should be changed. [TM 21/02/2018]
%
% The way that I reconstruct the canonical variates from MCCA was coded
% incorrectly. See line 174/175. [TM 02/07/2018]
%
% I have identified a rather large flaw with the original formulation that
% is also present in the paper.  'Lr' is the number of canonical variates
% that are computed via MCCA. It is the same for all data sets.  This
% should not be the case. When computing the number of pairwise
% correlations between dataset p and data set q, d_pq could be larger than
% Lr *or* correspond to dimensions that are not present in the MCCA
% canonical variates computed for dataset p and dataset q.  We need to
% compute all of the canonical variates for all of the data sets for the
% paradigm to make sense. I will update the code post haste. [TM 03/07/2018]
% ------------------------------------------------------------------------
function [CorrEst,x_corrs] = MCCA_CompleteModelSelection(X,ITC,Pfa,...
    varargin)

n_sets = size(X,1);
n_combs = nchoosek(n_sets,2);
x_corrs = combnk(1:n_sets,2);
m = zeros(1,n_sets);
for i = 1 : n_sets
    [m(i),M] = size(X{i});
end
%Lr = min(m);    % Right now I only compute canonical variates for each data
                % set up to the dimension of the smallest set. This should
                % be changed.
Lr = max(m);
if isempty(varargin)
    % Compute ON bases and concatentate
    U = cell(n_sets,1);
    metaMatrix = zeros(M,sum(m));
    m_temp = [0 m];
    for i = 1 : n_sets
        [U{i},~,~] = svd(X{i}',0);
        U{i} = U{i}(:,1:m(i));
        metaMatrix(:,sum(m_temp(1:i))+1:sum(m_temp(1:i+1))) = U{i};
    end
else
    % Just concatenate if provided with ON bases 
    U = varargin{1};
    metaMatrix = zeros(M,sum(m));
    m_temp = [0 m];
    for i = 1 : n_sets
        metaMatrix(:,sum(m_temp(1:i))+1:sum(m_temp(1:i+1))) = U{i};
    end
end

CorrEst = zeros(n_combs,max(m));


%% Compute canonical variates according to the MAXVAR criteria
% ----------------------------------------------------------------
[~,~,right]=svd(metaMatrix,0);
G = U;
F = right;
on = cell(n_sets,1);
% mLr = repmat(Lr,1,n_sets); % Edit 02.07.2018 - this is wrong
mLr = m; % Edit 02.07.2018 - this is right
mLr_temp = [0, mLr];
mLr_old = mLr_temp;
mLr_new = mLr_temp;
% We need to set up some stuff to accomodate for the fact that eventually
% subspaces will have zero dimensions [TM - 03.07.2018]
for i = 1 : Lr
    mLr_new(2:end) = mLr_old(2:n_sets+1)-1; % old. - could go negative
    mLr_new(2:end) = max(mLr_old(2:n_sets+1)-1,0); % new. - hopefully fixed.
    grammatrix = zeros(M,sum(mLr_new));
    for j = 1 : n_sets
        if rank(G{j})>0
            on{j}(:,i) = G{j}*F(sum(mLr_old(1:j))+1:...
                sum(mLr_old(1:j+1)),1);
            on{j}(:,i) = on{j}(:,i)./norm(on{j}(:,i));
            G{j} = G{j} - on{j}(:,i)*(on{j}(:,i)'*G{j});
            [q,~,~] = svd(G{j},0);
            G{j} = q(:,1:mLr_new(j+1));
            grammatrix(:,sum(mLr_new(1:j))+1:...
                sum(mLr_new(1:j+1))) = G{j};
        end
    end
    mLr_old = mLr_new;
    [~,~,F] = svd(grammatrix,0);
end

%% Model selection
% ----------------------------------------------------------------
for i = 1 : n_combs
    % Compute the pairwise order correlation with maxmin PCA-CCA 
    % See reference [2] for details. Originally coded by Yang Song.
    n_p = m(x_corrs(i,1));
    n_q = m(x_corrs(i,2));
    smin = zeros(n_p,n_q);
    for r1 = 1:n_p
        for r2 = 1:n_q
            r = min(r1,r2);
            C = zeros(r,1);
            T = zeros(r,1);
            ga = svd(U{x_corrs(i,1)}(:,1:r1)'*U{x_corrs(i,2)}(:,1:r2));
            for r3 = 0:r-1
                switch lower(ITC)
                    case 'ht'
                        C(r3+1) = -(M-r3-1/2*(r1+r2+1)+sum(ga(1:r3).^-2))...
                            *log(prod(1-ga(r3+1:r).^2));
                        T(r3+1) = chi2inv(1-Pfa,(r1-r3)*(r2-r3));
                    case 'mdl'
                        C(r3+1) = -(M-r3-1/2*(r1+r2+1)+sum(ga(1:r3).^-2))...
                            *log(prod(1-ga(r3+1:r).^2));
                        T(r3+1) = (M-r3-1/2*(r1+r2+1)+sum(ga(1:r3).^-2))...
                            /M*log(M)*(r1-r3)*(r2-r3); % MDL threshold
                    case 'aic'
                        C(r3+1) = -(M-r3-1/2*(r1+r2+1)+sum(ga(1:r3).^-2))...
                            *log(prod(1-ga(r3+1:r).^2));
                        T(r3+1) = (M-r3-1/2*(r1+r2+1)+sum(ga(1:r3).^-2))...
                            /M*2*(r1-r3)*(r2-r3); % AIC threshold
                end
            end
            IDX = find(C-T<0);
            if isempty(IDX) 
                smin(r1,r2) = r;
            else
                smin(r1,r2) = IDX(1)-1; 
            end
        end
    end
    d = max(max(smin));
    % Find the extracted sources with the largest inner products
    A = on{x_corrs(i,1)};
    B = on{x_corrs(i,2)};
    ga = abs(diag(A'*B));
    [ga,Iga] = sort(ga,'descend');    

    % Determine which variates are correlated
    ta = false(1,length(ga));
    ta(1:d) = true;
    [~,tInd] = sort(Iga);
    CorrEst(i,1:length(ga)) = ta(tInd);
end 